This is the specification for the virtual machine of gt-verdigris. (v0.0.1)
Codenamed "glass", it is a little endian machine with a word size of 32 bits.
More than average care has been taken to ensure that all instructions of this
version of the ISA fits within 16 bits, while still retaining the potential for
backwards compatible extension.

//============================================================================\\
|| The instruction set                                                        ||
\\============================================================================//
The possible combinations of instructions ("instruction pages") with the
following criteria are shown below:
- Bytes padded to 32 bits
- Bytes displayed in little endian order
- Numbered in order of evaluation
- Key:
  - x: any hexadecimal literal between 1 to E inclusive
  - R: the register label, between 0 to F inclusive
  - F: the hexadecimal literal F
  - c: a constant hexadecimal number between 0 to F inclusive
1. xR RR __ __             | 3 register operation
2. Fx RR __ __             | 2 register operation
3. FF xR __ __             | 1 register operation
3. FF xR __ __ cc cc cc cc | 1 register operation plus 32 bit constant
4. FF Fx __ __             | 0 register operation
4. FF Fx __ __ cc cc cc cc | 0 register operation plus 32 bit constant

+------------------------------------------------------------------------------+
| The full list of instructions, grouped according to instruction pages:       |
+------------------------------------------------------------------------------+
3 Register operations:
-----------------------
- invalid_instruction X Y Z
Full name: zero trap instruction
Encoding 0X YZ __ __
Description: This is a "trap bit" combination. Trying to execute it will set the
             invalid_instruction flag.

- addr X Y Z
Full name: add register
Encoding: 1X YZ __ __
Description: Adds the contents of registers Y and Z, then stores the result in
             register X (X = Y + Z).
             Sets overflow and underflow flags.

- subr X Y Z
Full name: subtract register
Encoding: 2X YZ __ __
Description: Subtracts the contents of registers Z from Y, then stores the
             result in register X. (X = Y - Z)
             Sets overflow and underflow flags.

- mulr X Y Z
Full name: multiply register
Encoding: 3X YZ __ __
Description: Signed multiplies the contents of 32 bit registers X with Y,
             Storing the 64 bit result in the conjoined register Y:Z
             (Y:Z = X * Y)

- divr X Y Z
Full name: divide register
Encoding: 4X YZ __ __
Description: Signed divides the contents of the registers Y with Z,
             storing the result in the register X. (X = Y / Z)
             In case Z is zero, X is set to the maximum or minimum signed 32 bit
             integer depending on whether Y was positive or negative,
             respectively, to approximate, albeit crudely, the value of
             infinity.
             Sets the zero_div flag.

- fixmulr X Y Z
Full name: fixed poiont multiply register
Encoding: 5X YZ __ __
Description: Signed multiplies the contents of the 32 bit registers Y and Z,
             interpreted as a fixed point number (16.16), adjusting the
             resulting number to fit within said format and storing the result
             in register X (X = Y * Z)
             Sets overflow and underflow flags.

- fixdivr X Y Z
Full name: fixed point divide register
Encoding: 6X YZ __ __
Description: Signed divides the contents of the 32 bit registers Y and Z,
             interpreted as a fixed point number (16.16), adjusting the
             resulting number to fit within said format and storing the result
             to register X. (X = Y / Z)
             In case Z is zero, X is set to the maximum or minimum signed 32 bit
             integer depending on whether Y was positive or negative,
             respectively, to approximate, albeit crudely, the value of
             infinity.
             Sets the divide-by-zero flag.

- reserved_instruction X Y Z
Full name: reserved instruction
Encoding: 7X YZ __ __ through EX YZ __ __
Description: These bit combinations are currently reserved. Trying to execute
             them will result in the reserved_instruction flag being set.

2 Register operations:
-----------------------
- invalid_instruction X Y
Full name: zero trap instruction
Encoding F0 XY __ __
Description: This is a "trap bit" combination. Trying to execute it will set the
             invalid_instruction flag.

- writer X Y
Full name: write register to pointer
Encoding: F1 XY __ __
Description: Writes the contents of X to the memory address pointed to by Y.
             There are no alignment restrictions of Y, but it is considered to
             be good practice to keep the alignment to the word size.

- readr X Y
Full name: read register from pointer
Encoding: F2 XY __ __
Description: Reads the contents of X from the memory address pointed to by Y.
             There are no alignment restrictions of Y, but it is considered to
             be good practice to keep the alignment to the word size.

- movr X Y
Full name: move register to register
Encoding: F3 XY __ __
Description: Copies register contents from Y to X. (X = Y)

- cmpr X Y
Full name: compare registers
Encoding F4 XY __ __
Description: Signed subtracts the contents of registers Y from X, then
             uses the result to set the following flags:
             equal, greater_than, less_than

- lshiftr X Y
Full name: logical shift register
Encoding: F5 XY __ __
Description: Logically shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             value of register Y.
             The direction is determined by the sign of the value of register Y,
             which is interpreted as a twos complement binary number. A positive
             value indicates a left shift, else a right shift.

- ashiftr X Y
Full name: arithmetic shift register
Encoding: F6 XY __ __
Description: Signed multiplies the contents of register X by 2 to the power Y.
             The magnitude of the shift is determined by the magnitude of the
             value of register Y.
             The direction is determined by the sign of the value of register Y,
             which is interpreted as a twos complement binary number. A positive
             value indicates a left shift, else a right shift.

- rollr X Y
Full name: roll register
Encoding: F7 XY __ __
Description: Rolls the contents of register X by the amount represented by the
             contents of register Y, interpreted as a twos complement signed
             integer. A positive value of Y rolls left, and a negative rolls
             right.

- andr X Y
Full name: binary and register
Encoding: F8 XY __ __
Description: Computes the binary AND operation of the contents of registers
             X and Y, then stores the result to register X.

- orr X Y
Full name: binary or register
Encoding: F9 XY __ __
Description: Computes the binary OR operation of the contents of registers
             X and Y, then stores the result to register X.

- xorr X Y
Full name: binary xor register
Encoding: FA XY __ __
Description: Computes the binary XOR operation of the contents of registers
             X and Y, then stores the result to register X.

- reserved_instruction X Y
Full name: reserved instruction
Encoding: FB XY __ __ through FE XY __ __
Description: This bit combination is currently reserved. Trying to execute
             it will result in the reserved_instruction flag being set.

1 Register operations:
-----------------------
- invalid_instruction X
Full name: zero trap instruction
Encoding FF 0X __ __
Description: This is a "trap bit" combination. Trying to execute it will set the
             invalid_instruction flag.

- readc X const
Full name: read constant to register
Encoding: FF 1X __ __ + const
Description: Copies the 32 bit constant to the register X.

- writec X const
Full name: write register to constant pointer
Encoding: FF 2X __ __ + const
Description: Writes the contents of the register X to the address provided in the constant.

- movc X const
Full name: move constant to register
Encoding: FF 3X __ __ + const
Description: Copies the constant provided in the instruction to the register X.

- jmpr X
Full name: unconditional jump to register
Encoding: FF 4X __ __
Description: Assigns address contained by register X to the instruction pointer.

- cmpc X const
Full name: compare register with constant
Encoding: FF 5X __ __ + const
Description: Performs a signed subtraction with the register X and the constant.
             The result is then parsed to set the following flags:
             equal, greater_than, less_than

- lshiftc X const
Full name: logical shift register by constant
Encoding: FF 6X __ __ + const
Description: Logical shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             constant.
             The direction is determined by the sign of the value of the
             constant, which is interpreted as a twos complement binary number.
             A positive value indicates a left shift, else a right shift.

- ashiftc X const
Full name: arithmetic shift register by constant
Encoding: FF 7X __ __ + const
Description: Arithmetic shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             constant.
             The direction is determined by the sign of the value of the
             constant, which is interpreted as a twos complement binary number.
             A positive value indicates a left shift, else a right shift.

- rollc X const
Full name: roll register by constant
Encoding: FF 8X __ __ + const
Description: Rolls the contents of register X by the amount represented by the
             constant, interpreted as a twos complement signed
             integer. A positive value of Y rolls left, and a negative rolls
             right.

- andc X const
Full name: binary and constant
Encoding: FF 9X __ __ + const
Description: Computes the binary AND operation of the contents of register X
             and the constant, then stores the result to register X.

- orc X const
Full name: binary or constant
Encoding: FF AX __ __ + const
Description: Computes the binary OR operation of the contents of register X
             and the constant, then stores the result to register X.

- notr X 
Full name: binary not register
Encoding: FF BX __ __
Description: Computes the binary NOT operation of the contents of register X,
             then stores the result to register X.

- xorc X const
Full name: binary xor constant
Encoding: FF CX __ __ + const
Description: Computes the binary XOR operation of the contents of register X
             and the constant, then stores the result to register X.

- reserved_instruction X
Full name: reserved instruction
Encoding: FF DX __ __ through FF EX __ __
Description: These bit combinations are currently reserved. Trying to execute
             them will result in the reserved_instruction flag being set.

0 Register operations:
-----------------------
- invalid_instruction
Full name: zero trap instruction
Encoding FF F0 __ __
Description: This is a "trap bit" combination. Trying to execute it will set the
             invalid_instruction flag.

- nop
Full name: no operation
Encoding: FF F1 __ __
Description: Does nothing.

- jmp const
Full name: unconditional jump
Encoding: FF F2 __ __ + const
Description: Sets the instruction pointer to the constant.

- je const
Full name: jump if equal
Encoding: FF F3 __ __ + const
Description: If the equal flag is set, sets the instruction pointer to the
             constant.

- jg const
Full name: jump if greater than
Encoding: FF F4 __ __ + const
Description: If the greater_than flag is set, sets the instruction pointer to the
             constant.

- jl const
Full name: jump if less than
Encoding: FF F5 __ __ + const
Description: If the less_than flag is set, sets the instruction pointer to the
             constant.

- reserved_instruction
Full name: reserved instruction
Encoding: FF F6 __ __ through FF FE __ __
Description: These bit combinations are currently reserved. Trying to execute
             them will result in the reserved_instruction flag being set.

//============================================================================\\
|| The registers                                                              ||
\\============================================================================//
All registers used by this virtual machine and their purpose is described below.
- R0 through RF
Full name: Register 0 through Register 16
Description: These are general purpose registers.

- RIP
Full name: Instruction pointer
Description: Contains the address of the next instruction to be executed.

- FLAGS
Full name: Flags register
Description: Contains state of this CPU.
Bit values (in big endian order):
  00: equal
  01: greater_than
  02: less_than
  03: reserved_instruction
  04: invalid_instruction
  05: zero_div
  06: overflow
  07: underflow
  08 through 1F: reserved

Flags register handler:
- equal =
- greater_than =
- less_than =
- reserved_instruction = opcode == INVALID_RESERVED
- invalid_instruction = opcode == INVALID_ZERO || INVALID_NEXT_INSTR_PAGE
- zero_div = 
- overflow = 
- underflow =
- 08 through 1F = 0


//============================================================================\\
|| Instruction decoding                                                       ||
\\============================================================================//
The decoding logic is fairly simple. In order, these are the steps to be taken
to determine the instruction page:
- First instruction page
  The assumption is that X in X_ __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the first instruction page.
- Second instruction page
  The assumption is that X in FX __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the second instruction page.
- Third instruction page
  The assumption is that X in FF X_ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the third instruction page.
- Fourth instruction page
  The assumption is that X in FF FX __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the fourth instruction page.
- Error
  The algorithm has decided one of the following:
  - This is an instruction from a future ISA,
  - There's a memory error in the program the VM is running,
  - The host machine is malfunctioning.

//============================================================================\\
|| Instruction execution cycle                                                ||
\\============================================================================//
FFF1 0000 FFF1 0000
FFF1 FFF1 FFF1 FFF1
The steps of executing an instruction, from start to finish, are:
- Fetch word from memory at address pointed to by RIP 
- Zero or otherwise ignore the 2 least significant bytes
- Pass the resulting 16 bit instruction to the decoder
- Use the data from the decoder to execute the opcode
- If opcode has constant, RIP += 2 else RIP += 3 (bytes)
- Call the flags register handler using opcode info
