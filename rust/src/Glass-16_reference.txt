~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//============================================================================\\
|| Green Top: Verdigris "Glass-16" Virtual Machine technical reference        ||
\\============================================================================//
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v0.0.1

==[ About ]=====================================================================
Glass-16 is an interpreted programming language intended to be used for hosting
Green Top: Verdigris (shortened to "gtv"). This decision came about to be after
facing a barrier porting the game, while in early development, to an old version
of linux, coming in the form of the compiler for the odin programming language
being unable to be run nor be compiled. It is hoped that porting the game to
other platforms will only involve implementing this language for the target
platform.

==[ Specification ]=============================================================
This section describes the memory model and registers.

Memory model
-------------
One Glass-16 instance is capable of addressing up to ~65.5 KiB (65,535 bytes)
of RAM, from location 0x0000 to 0xFFFF inclusive.
As a measure to reduce the complexity of implementation, the language stores,
accesses and uses data and instructions in the same memory space.
The language is big-endian; in simple terms, what you see in the byte-formatted
memory dump directly corresponds to the layout of bytes in the registers.
As this language is intended to be emulated in machines capable of addressing
much, much larger amounts of memory, it is also intended for the host program
to "weld" the RAMs of multiple instances of the CPU, and use said instances as
a data fetcher of sorts, if more memory is needed.


Registers
----------
Glass-16 has 16 registers in total, all of which are 16 bits wide.
They're usually referred to as Rx, where x is a hexadecimal digit (0 through F).
While all of the registers are accessible through the instruction set, some are
used by the langauge for its own internal purposes.

- R0 through RD
Full name: Register 0 through Register 14
Description: These are general purpose registers.

- RE or RIP
Full name: Instruction pointer
Description: Contains the address of the next instruction to be executed.

- RF or RFLAGS
Full name: Flags register
Description: Contains state of this CPU.

Flags register
---------------
Bit values:
+0123-4567-89AB-CDEF+
|0000 0000 0000 0000|
+-------------------+
0: zero/equal
1: greater_than
2: less_than
3: zero_div

4: overflow
5: underflow
6: reserved_instruction
7: invalid_instruction

==[ The instruction set ]====================================================
Glass-16 instructions are either two or four bytes long.
For reading convenience, they are grouped in categories known as
"instruction pages".
+-------------+-------------------+
| Bit pattern | Instruction page  |
+-------------+-------------------+
| xR RR       | Page 0            |
|_____________|___________________|
| Fx RR       | Page 1            |
|_____________|___________________|
| FF xR       | Page 2            |
| FF xR cc cc |                   | 
|_____________|___________________|
| FF Fx       | Page 3            |
| FF Fx cc cc |                   | 
\_____________|___________________/
Key:
- x: any hexadecimal literal between 1 to E inclusive
- R: the register label, between 0 to F inclusive
- F: the hexadecimal literal F
- c: a constant hexadecimal number between 0 to F inclusive

Notes on flag behaviour:
- If instruction is not (reserved or invalid), those flags are set to zero.
- The other flags not mentioned in the "Flags set" field remains unchanged
  throughout execution of the instruction
+------------------------------------------------------------------------------+
+-[ Revisions needed from this point onward ]----------------------------------+
+------------------------------------------------------------------------------+
 
+------------------------------------------------------------------------------+
| The full list of instructions, grouped according to instruction pages:       |
+------------------------------------------------------------------------------+
3 Register operations:
-----------------------
- invalid_instruction
Full name: zero trap instruction
Encoding 00 00
Description: This is a "trap bit" combination, intended to catch bugs.
Flags turned on: invalid_instruction, zero

- reserved_instruction
Full name: reserved instruction
Encoding 0X YZ
Description: This combination, where nibbles X, Y and Z are != 0, is reserved.
Flags set: invalid_instruction, reserved_instruction

- addr X Y Z
Full name: add register
Encoding: 1X YZ
Description: Adds registers Y and Z, then stores the result in X (X = Y + Z).
Flags set: overflow, underflow

- subr X Y Z
Full name: subtract register
Encoding: 2X YZ
Description: Subtracts registers Z from Y, then stores the result in X.
             (X = Y - Z).
Flags set: overflow, underflow, zero

- mulr X Y Z
Full name: multiply register
Encoding: 3X YZ
Description: Signed multiplies registers X with Y,
             storing the result in conjoined register Y:Z.
             (Y:Z = X * Y).
Flags set: zero

- divr X Y Z
Full name: divide register
Encoding: 4X YZ
Description: Signed divides registers Y with Z, storing the result in X.
             (X = Y / Z).
             If Z is zero, X is set to the maximum or minimum signed
             integer depending on whether Y was positive or negative,
             respectively, to approximate the value of
             infinity, albeit crudely.
Flags set: zero_div

- reserved_instruction X Y Z
Full name: reserved instruction
Encoding: 5X YZ through EX YZ
Description: These bit combinations are currently reserved.
Flags set: invalid_instruction, reserved_instruction


2 Register operations:
-----------------------
- readr X Y
Full name: read register from pointer
Encoding: F0 XY __ __
Description: Reads the contents of X from the memory address pointed to by Y.
             There are no alignment restrictions of Y, but it is considered to
             be good practice to keep the alignment to the word size.

- writer X Y
Full name: write register to pointer
Encoding: F1 XY __ __
Description: Writes the contents of X to the memory address pointed to by Y.
             There are no alignment restrictions of Y, but it is considered to
             be good practice to keep the alignment to the word size.

- movr X Y
Full name: move register to register
Encoding: F2 XY __ __
Description: Copies register contents from Y to X. (X = Y)

- cmpr X Y
Full name: compare registers
Encoding F3 XY __ __
Description: Signed subtracts the contents of registers Y from X, then
             uses the result to set the following flags:
             equal, greater_than, less_than

- lshiftr X Y
Full name: logical shift register
Encoding: F4 XY __ __
Description: Logically shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             value of register Y.
             The direction is determined by the sign of the value of register Y,
             which is interpreted as a twos complement binary number. A positive
             value indicates a left shift, else a right shift.

- ashiftr X Y
Full name: arithmetic shift register
Encoding: F5 XY __ __
Description: Signed multiplies the contents of register X by 2 to the power Y.
             The magnitude of the shift is determined by the magnitude of the
             value of register Y.
             The direction is determined by the sign of the value of register Y,
             which is interpreted as a twos complement binary number. A positive
             value indicates a left shift, else a right shift.

- rollr X Y
Full name: roll register
Encoding: F6 XY __ __
Description: Rolls the contents of register X by the amount represented by the
             contents of register Y, interpreted as a twos complement signed
             integer. A positive value of Y rolls left, and a negative rolls
             right.

- andr X Y
Full name: binary and register
Encoding: F7 XY __ __
Description: Computes the binary AND operation of the contents of registers
             X and Y, then stores the result to register X.

- orr X Y
Full name: binary or register
Encoding: F8 XY __ __
Description: Computes the binary OR operation of the contents of registers
             X and Y, then stores the result to register X.

- xorr X Y
Full name: binary xor register
Encoding: F9 XY __ __
Description: Computes the binary XOR operation of the contents of registers
             X and Y, then stores the result to register X.

- reserved_instruction X Y
Full name: reserved instruction
Encoding: FA XY __ __ through FE XY __ __
Description: This bit combination is currently reserved. Trying to execute
             it will result in the reserved_instruction flag being set.

1 Register operations:
-----------------------
- readc X const
Full name: read constant to register
Encoding: FF 0X __ __ + const
Description: Copies the 32 bit constant to the register X.

- writec X const
Full name: write register to constant pointer
Encoding: FF 1X __ __ + const
Description: Writes the contents of the register X to the address provided in the constant.

- movc X const
Full name: move constant to register
Encoding: FF 2X __ __ + const
Description: Copies the constant provided in the instruction to the register X.

- jmpr X
Full name: unconditional jump to register
Encoding: FF 3X __ __
Description: Assigns address contained by register X to the instruction pointer.

- cmpc X const
Full name: compare register with constant
Encoding: FF 4X __ __ + const
Description: Performs a signed subtraction with the register X and the constant.
             The result is then parsed to set the following flags:
             equal, greater_than, less_than

- lshiftc X const
Full name: logical shift register by constant
Encoding: FF 5X __ __ + const
Description: Logical shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             constant.
             The direction is determined by the sign of the value of the
             constant, which is interpreted as a twos complement binary number.
             A positive value indicates a left shift, else a right shift.

- ashiftc X const
Full name: arithmetic shift register by constant
Encoding: FF 6X __ __ + const
Description: Arithmetic shifts the contents of register X.
             The magnitude of the shift is determined by the magnitude of the
             constant.
             The direction is determined by the sign of the value of the
             constant, which is interpreted as a twos complement binary number.
             A positive value indicates a left shift, else a right shift.

- rollc X const
Full name: roll register by constant
Encoding: FF 7X __ __ + const
Description: Rolls the contents of register X by the amount represented by the
             constant, interpreted as a twos complement signed
             integer. A positive value of Y rolls left, and a negative rolls
             right.

- andc X const
Full name: binary and constant
Encoding: FF 8X __ __ + const
Description: Computes the binary AND operation of the contents of register X
             and the constant, then stores the result to register X.

- orc X const
Full name: binary or constant
Encoding: FF 9X __ __ + const
Description: Computes the binary OR operation of the contents of register X
             and the constant, then stores the result to register X.

- notr X 
Full name: binary not register
Encoding: FF AX __ __
Description: Computes the binary NOT operation of the contents of register X,
             then stores the result to register X.

- xorc X const
Full name: binary xor constant
Encoding: FF BX __ __ + const
Description: Computes the binary XOR operation of the contents of register X
             and the constant, then stores the result to register X.

- chkflag X
Full name: check flags register
Encoding: FF CX __ __
Description: Checks whether a flag at index X is set or not, by setting the is_equal flag
             Out of range flags always set the is_equal flag to 0.

- reserved_instruction X
Full name: reserved instruction
Encoding: FF DX __ __ through FF EX __ __
Description: These bit combinations are currently reserved. Trying to execute
             them will result in the reserved_instruction flag being set.

0 Register operations:
-----------------------
- nop
Full name: no operation
Encoding: FF F0 __ __
Description: Does nothing.

- jmp const
Full name: unconditional jump
Encoding: FF F1 __ __ + const
Description: Sets the instruction pointer to the constant.

- je const
Full name: jump if equal
Encoding: FF F2 __ __ + const
Description: If the equal flag is set, sets the instruction pointer to the
             constant.

- jg const
Full name: jump if greater than
Encoding: FF F3 __ __ + const
Description: If the greater_than flag is set, sets the instruction pointer to the
             constant.

- jl const
Full name: jump if less than
Encoding: FF F4 __ __ + const
Description: If the less_than flag is set, sets the instruction pointer to the
             constant.

- reserved_instruction
Full name: reserved instruction
Encoding: FF F5 __ __ through FF FE __ __
Description: These bit combinations are currently reserved. Trying to execute
             them will result in the reserved_instruction flag being set.

//============================================================================\\
|| The registers (todo: mix rip, flags, etc with the general purpose regs)    ||
\\============================================================================//



//============================================================================\\
|| Instruction decoding                                                       ||
\\============================================================================//
The decoding logic is fairly simple. In order, these are the steps to be taken
to determine the instruction page:
- First instruction page
  The assumption is that X in X_ __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the first instruction page.
- Second instruction page
  The assumption is that X in FX __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the second instruction page.
- Third instruction page
  The assumption is that X in FF X_ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the third instruction page.
- Fourth instruction page
  The assumption is that X in FF FX __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the fourth instruction page.
- Error
  The algorithm has decided one of the following:
  - This is an instruction from a future ISA,
  - There's a memory error in the program the VM is running,
  - The host machine is malfunctioning.

//============================================================================\\
|| Instruction execution cycle                                                ||
\\============================================================================//
FFF1 0000 FFF1 0000
FFF1 FFF1 FFF1 FFF1
The steps of executing an instruction, from start to finish, are:
- Fetch word from memory at address pointed to by RIP 
- Zero or otherwise ignore the 2 least significant bytes
- Pass the resulting 16 bit instruction to the decoder
- Use the data from the decoder to execute the opcode
- If opcode has constant, RIP += 2 else RIP += 3 (bytes)
- Call the flags register handler using opcode info
