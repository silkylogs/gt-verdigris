~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//============================================================================\\
|| Green Top: Verdigris "Glass-16" Virtual Machine technical reference        ||
\\============================================================================//
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v0.0.1

==[ About ]=====================================================================
Glass-16 is an interpreted programming language intended to be used for hosting
Green Top: Verdigris (shortened to "gtv"). This decision came about to be after
facing a barrier porting the game, while in early development, to an old version
of linux, coming in the form of the compiler for the odin programming language
being unable to be run nor be compiled. It is hoped that porting the game to
other platforms will only involve implementing this language for the target
platform.

==[ Specification ]=============================================================
This section describes the memory model and registers.

Memory model
-------------
One Glass-16 instance is capable of addressing up to ~65.5 KiB (65,535 bytes)
of RAM, from location 0x0000 to 0xFFFF inclusive.
As a measure to reduce the complexity of implementation, the language stores,
accesses and uses data and instructions in the same memory space.
The language is big-endian; in simple terms, what you see in the byte-formatted
memory dump directly corresponds to the layout of bytes in the registers.
As this language is intended to be emulated in machines capable of addressing
much, much larger amounts of memory, it is also intended for the host program
to "weld" the RAMs of multiple instances of the CPU, and use said instances as
a data fetcher of sorts, if more memory is needed.


Registers
----------
Glass-16 has 16 registers in total, all of which are 16 bits wide.
They're usually referred to as Rx, where x is a hexadecimal digit (0 through F).
While all of the registers are accessible through the instruction set, some are
used by the langauge for its own internal purposes.

- R0 through RD
Full name: Register 0 through Register 14
Description: These are general purpose registers.

- RE or RIP
Full name: Instruction pointer
Description: Contains the address of the next instruction to be executed.

- RF or RFLAGS
Full name: Flags register
Description: Contains state of this CPU.

Flags register
---------------
Bit values:
+0123-4567-89AB-CDEF+
|0000 0000 0000 0000|
+-------------------+
0: zero/equal
1: greater_than
2: less_than
3: zero_div

4: overflow
5: underflow
6: reserved_instruction
7: invalid_instruction

==[ The instruction set ]====================================================
Glass-16 instructions are either two or four bytes long.
For reading convenience, they are grouped in categories known as
"instruction pages".
+-------------+-------------------+
| Bit pattern | Instruction page  |
+-------------+-------------------+
| xR RR       | Page 0            |
|_____________|___________________|
| Fx RR       | Page 1            |
|_____________|___________________|
| FF xR       | Page 2            |
| FF xR cc cc |                   | 
|_____________|___________________|
| FF Fx       | Page 3            |
| FF Fx cc cc |                   | 
\_____________|___________________/
Key:
- x: any hexadecimal literal between 1 to E inclusive
- R: the register label, between 0 to F inclusive
- F: the hexadecimal literal F
- c: a constant hexadecimal number between 0 to F inclusive

Notes on flag behaviour:
- If instruction is not (reserved or invalid), those flags are set to zero.
- The other flags not mentioned in the "Flags set" field remains unchanged
  throughout execution of the instruction.
  If not otherwise mentioned, those flags will be set to 1.
- Comparison flags (equal, greater_than, less_than), are set to zero once an
  instruction executes, except when it is a comparison instruction.
  (rewording needed?)

--[ Glass-16 instruction list ]-------------------------------------------------
Instruction page 0:
--------------------
- zero_trap_instruction
Full name: zero trap instruction
Encoding 00 00
Description: This is a "trap bit" combination, intended to catch bugs.
Flags set: invalid_instruction, zero

- cmov X Y Z
Full name: conditional move
Encoding: 0X YZ
Description: X=index to RF, Y=dest, Z=src
Flags set: 
Note: Conditional jump is simulated by setting X to 0xE, that is, using RE/RIP
      as the operand register.

- addr X Y Z
Full name: add register
Encoding: 1X YZ
Description: Adds registers Y and Z, then stores the result in X (X = Y + Z).
Flags set: overflow, underflow, zero

- subr X Y Z
Full name: subtract register
Encoding: 2X YZ
Description: Subtracts registers Z from Y, then stores the result in X.
             (X = Y - Z).
             Implementor's note: This is equivalent to X = Y + (0x8000 XOR Z)
Flags set: overflow, underflow, zero

- mulr X Y Z
Full name: multiply register
Encoding: 3X YZ
Description: Signed multiplies registers X with Y,
             storing the result in conjoined register Y:Z.
             (Y:Z = X * Y).
Flags set: zero

- divr X Y Z
Full name: divide register
Encoding: 4X YZ
Description: Signed divides registers Y with Z, storing the result in X.
             (X = Y / Z).
             If Z is zero, X is set to the maximum or minimum signed
             integer depending on whether Y was positive or negative
             respectively to approximate the value of infinity, albeit crudely.
Flags set: zero_div

- reserved_instruction X Y Z
Full name: reserved instruction
Encoding: 5X YZ through EX YZ
Description: These bit combinations are currently reserved.
Flags set: invalid_instruction, reserved_instruction

Instruction page 1:
--------------------
- ldr X Y
Full name: load register from pointer
Encoding: F0 XY
Description: Reads the contents of X from the memory address pointed to by Y.
Flags set:

- stor X Y
Full name: store register to pointer
Encoding: F1 XY
Description: Writes the contents of X to the memory address pointed to by Y.
Flags set:

- movr X Y
Full name: move register to register
Encoding: F2 XY
Description: Copies register contents from Y to X. (X = Y)
Flags set:

- cmpr X Y
Full name: compare registers
Encoding F3 XY
Description: Subtracts register Y from X, discarding the result.
Flags set: equal, greater_than, less_than

- lshiftr X Y
Full name: logical shift register
Encoding: F4 XY
Description: Logically shifts registers X by Y, interpreted as a twos
             complement signed binary number.
             The shift's magnitude is determined by the constant's magnitude.
             The shift's direction is determined by the constant's sign bit.
             A positive value shifts left, shifts right.
Flags set:

- ashiftr X Y
Full name: arithmetic shift register
Encoding: F5 XY
Description: Multiplies registers X with 2^Y, both interpreted as a twos
             complement signed binary number.
Flags set:

- andr X Y
Full name: binary and register
Encoding: F6 XY
Description: Computes the binary AND operation of the contents of registers
             X and Y, then stores the result to register X.
Flags set:

- orr X Y
Full name: binary or register
Encoding: F7 XY
Description: Computes the binary OR operation of the contents of registers
             X and Y, then stores the result to register X.
Flags set:

- xorr X Y
Full name: binary xor register
Encoding: F8 XY
Description: Computes the binary XOR operation of the contents of registers
             X and Y, then stores the result to register X.
Flags set:

- chkbit X Y
Full name: check bit
Encoding: F9 XY
Description: Checks whether bit Y is set in X, where Y is a signed integer.
             If Y is out of range [0, F], is_equal is always set to 0.
             This is intended to be used to probe the flags register.
Flags set: is_equal

- setbit X Y
Full name: set bit
Encoding: FA XY
Description: Sets bit Y in register X, where Y is a signed integer.
             No effect if Y is out of range [0, F].
Flags set: is_equal

- reserved_instruction X Y
Full name: reserved instruction
Encoding: F9 XY through FE XY
Description: These bit combinations are currently reserved.
Flags set: invalid_instruction, reserved_instruction

Instruction page 2:
--------------------
- ldc X const
Full name: load constant to register
Encoding: FF 0X cc cc
Description: Copies the constant to the register X.
Flags set: 
Note: If the instruction is at, say, 0xFFFE, the constant read would be at addr
      0x0000 and 0x0001.
      TODO specify this in the "instruction execution cycle" page?

- stoc X const
Full name: store register to address
Encoding: FF 1X cc cc
Description: Writes the contents of the register X to the constant address.
Flags set:

- movc X const
Full name: move constant to register
Encoding: FF 2X cc cc
Description: Copies the constant provided in the instruction to the register X.
Flags set:
Note: Unconditional jump is simulated by setting X to 0xE, that is, using RE/RIP
      as the operand register.

- cmpc X const
Full name: compare register with constant
Encoding: FF 3X cc cc
Description: Subtracts register X from the constant, discarding the result.
Flags set: equal, greater_than, less_than

- lshiftc X const
Full name: logical shift register by constant
Encoding: FF 4X cc cc
Description: Logical shifts register X by the constant, interpreted as a twos
             complement signed binary number.
             The shift's magnitude is determined by the constant's magnitude.
             The shift's direction is determined by the constant's sign bit.
             A positive value shifts left, shifts right.
Flags set:

- ashiftc X const
Full name: arithmetic shift register by constant
Encoding: FF 5X cc cc
Description: Multiplies registers X with 2^constant, both interpreted as a twos
             complement signed binary number.
Flags set:

- andc X const
Full name: binary and constant
Encoding: FF 6X cc cc
Description: Computes the binary AND operation of the contents of register X
             and the constant, then stores the result to register X.
Flags set:

- orc X const
Full name: binary or constant
Encoding: FF 7X cc cc
Description: Computes the binary OR operation of the contents of register X
             and the constant, then stores the result to register X.
Flags set:

- xorc X const
Full name: binary xor constant
Encoding: FF 8X cc cc
Description: Computes the binary XOR operation of the contents of register X
             and the constant, then stores the result to register X.
Flags set:

- notr X 
Full name: binary not register
Encoding: FF 9X
Description: Computes the binary NOT operation of the contents of register X,
             then stores the result to register X.
Flags set:

- reserved_instruction X
Full name: reserved instruction
Encoding: FF AX __ __ through FF EX __ __
Description: These bit combinations are currently reserved.
Flags set: invalid_instruction, reserved_instruction

Instruction page 3:
--------------------
- nop
Full name: no operation
Encoding: FF F0
Description: Does nothing.
Flags set:

- reserved_instruction
Full name: reserved instruction
Encoding: FF F1 through FF FE
Description: These bit combinations are currently reserved.
Flags set: invalid_instruction, reserved_instruction

+------------------------------------------------------------------------------+
+-[ Revisions needed from this point onward ]----------------------------------+
+------------------------------------------------------------------------------+
 
//============================================================================\\
|| Instruction decoding                                                       ||
\\============================================================================//
The decoding logic is fairly simple. In order, these are the steps to be taken
to determine the instruction page:
- First instruction page
  The assumption is that X in X_ __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the first instruction page.
- Second instruction page
  The assumption is that X in FX __ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the second instruction page.
- Third instruction page
  The assumption is that X in FF X_ __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the third instruction page.
- Fourth instruction page
  The assumption is that X in FF FX __ __ is between 0x0 and 0xE inclusive.
  If X == 0xF, continue; else the instruction is in the fourth instruction page.
- Error
  The algorithm has decided one of the following:
  - This is an instruction from a future ISA,
  - There's a memory error in the program the VM is running,
  - The host machine is malfunctioning.

//============================================================================\\
|| Instruction execution cycle                                                ||
\\============================================================================//
FFF1 0000 FFF1 0000
FFF1 FFF1 FFF1 FFF1
The steps of executing an instruction, from start to finish, are:
- Fetch word from memory at address pointed to by RIP 
- Zero or otherwise ignore the 2 least significant bytes
- Pass the resulting 16 bit instruction to the decoder
- Use the data from the decoder to execute the opcode
- If opcode has constant, RIP += 2 else RIP += 3 (bytes)
- Call the flags register handler using opcode info
